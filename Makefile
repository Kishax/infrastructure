# Kishax Infrastructure Makefile
# Terraform + EC2環境用

# .envファイルが存在する場合は読み込む
ifneq (,$(wildcard ./.env))
    include .env
    export
endif

# AWS Profile設定
AWS_PROFILE ?= AdministratorAccess-126112056177
AWS_REGION ?= ap-northeast-1
ENVIRONMENT ?= production
export AWS_PROFILE
export AWS_REGION
export ENVIRONMENT

# SSH Key設定
SSH_KEY = ./minecraft.pem

.PHONY: help
help: ## ヘルプを表示
	@echo "Kishax Infrastructure Makefile (Terraform + EC2)"
	@echo ""
	@echo "利用可能なコマンド:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-25s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)

## =============================================================================
## 環境変数管理
## =============================================================================

.PHONY: env-check
env-check: ## .envファイルの存在確認
	@if [ ! -f .env ]; then \
		echo "❌ .envファイルが見つかりません"; \
		echo "💡 以下のコマンドで作成してください:"; \
		echo "   cp .env.example .env"; \
		echo "   vi .env  # POSTGRES_PASSWORD と MYSQL_PASSWORD を設定"; \
		exit 1; \
	fi
	@echo "✅ .envファイルが存在します"

.PHONY: env-load
env-load: env-check ## Terraform outputから環境変数を読み込む
	@echo "📥 環境変数をTerraform outputから読み込んでいます..."
	@if [ ! -f .env ]; then \
		echo "❌ .envファイルが見つかりません"; \
		exit 1; \
	fi
	@bash -c ' \
		set -e; \
		source .env; \
		echo "# Auto-generated by make env-load at $$(date)" > .env.auto; \
		echo "" >> .env.auto; \
		echo "# RDS Endpoints" >> .env.auto; \
		echo "export RDS_POSTGRES_ENDPOINT=\"$$(cd terraform && terraform output -raw postgres_endpoint 2>/dev/null)\"" >> .env.auto; \
		echo "export RDS_MYSQL_ENDPOINT=\"$$(cd terraform && terraform output -raw mysql_endpoint 2>/dev/null)\"" >> .env.auto; \
		echo "export RDS_POSTGRES_HOST=\"$$(cd terraform && terraform output -raw postgres_endpoint 2>/dev/null | cut -d: -f1)\"" >> .env.auto; \
		echo "export RDS_POSTGRES_PORT=\"$$(cd terraform && terraform output -raw postgres_endpoint 2>/dev/null | cut -d: -f2)\"" >> .env.auto; \
		echo "export RDS_MYSQL_HOST=\"$$(cd terraform && terraform output -raw mysql_endpoint 2>/dev/null | cut -d: -f1)\"" >> .env.auto; \
		echo "export RDS_MYSQL_PORT=\"$$(cd terraform && terraform output -raw mysql_endpoint 2>/dev/null | cut -d: -f2)\"" >> .env.auto; \
		echo "" >> .env.auto; \
		echo "# SQS" >> .env.auto; \
		echo "export TO_WEB_QUEUE_URL=\"$$(cd terraform && terraform output -raw to_web_queue_url 2>/dev/null)\"" >> .env.auto; \
		echo "export TO_MC_QUEUE_URL=\"$$(cd terraform && terraform output -raw to_mc_queue_url 2>/dev/null)\"" >> .env.auto; \
		echo "export TO_DISCORD_QUEUE_URL=\"$$(cd terraform && terraform output -raw discord_queue_url 2>/dev/null)\"" >> .env.auto; \
		echo "export MC_WEB_SQS_ACCESS_KEY_ID=\"$$(cd terraform && terraform output -raw sqs_access_key_id 2>/dev/null)\"" >> .env.auto; \
		echo "export MC_WEB_SQS_SECRET_ACCESS_KEY=\"$$(cd terraform && terraform output -raw sqs_secret_access_key 2>/dev/null)\"" >> .env.auto; \
		echo "" >> .env.auto; \
		echo "# S3" >> .env.auto; \
		echo "export S3_BUCKET=\"$$(cd terraform && terraform output -raw s3_docker_images_bucket_name 2>/dev/null)\"" >> .env.auto; \
		echo "export S3_IMAGE_MAPS_BUCKET=\"$$(cd terraform && terraform output -raw s3_image_maps_bucket_name 2>/dev/null)\"" >> .env.auto; \
		echo "export S3_WORLD_BACKUPS_BUCKET=\"$$(cd terraform && terraform output -raw s3_world_backups_bucket_name 2>/dev/null)\"" >> .env.auto; \
		echo "" >> .env.auto; \
		echo "# EC2 Instance IDs" >> .env.auto; \
		echo "export INSTANCE_ID_A=\"$$(cd terraform && terraform output -raw mc_server_instance_id 2>/dev/null)\"" >> .env.auto; \
		echo "export INSTANCE_ID_B=\"$$(cd terraform && terraform output -raw api_server_instance_id 2>/dev/null)\"" >> .env.auto; \
		echo "export INSTANCE_ID_C=\"$$(cd terraform && terraform output -raw web_server_instance_id 2>/dev/null)\"" >> .env.auto; \
		echo "export INSTANCE_ID_D=\"$$(cd terraform && terraform output -raw jump_server_instance_id 2>/dev/null)\"" >> .env.auto; \
		echo "" >> .env.auto; \
		echo "# EC2 Private IPs" >> .env.auto; \
		INST_A=$$(cd terraform && terraform output -raw mc_server_instance_id 2>/dev/null); \
		INST_B=$$(cd terraform && terraform output -raw api_server_instance_id 2>/dev/null); \
		INST_C=$$(cd terraform && terraform output -raw web_server_instance_id 2>/dev/null); \
		echo "export INSTANCE_ID_A_PRIVATE_IP=\"$$(aws ec2 describe-instances --instance-ids $$INST_A --query Reservations[0].Instances[0].PrivateIpAddress --output text 2>/dev/null || echo "")\"" >> .env.auto; \
		echo "export INSTANCE_ID_B_PRIVATE_IP=\"$$(aws ec2 describe-instances --instance-ids $$INST_B --query Reservations[0].Instances[0].PrivateIpAddress --output text 2>/dev/null || echo "")\"" >> .env.auto; \
		echo "export INSTANCE_ID_C_PRIVATE_IP=\"$$(aws ec2 describe-instances --instance-ids $$INST_C --query Reservations[0].Instances[0].PrivateIpAddress --output text 2>/dev/null || echo "")\"" >> .env.auto; \
		echo "" >> .env.auto; \
		echo "# Note: POSTGRES_PASSWORD and MYSQL_PASSWORD are defined in .env" >> .env.auto; \
		echo "# They are not re-exported here to avoid shell variable expansion issues" >> .env.auto; \
		echo "✅ 環境変数を .env.auto に保存しました"; \
		echo "💡 以下のコマンドで読み込んでください:"; \
		echo "   source .env && source .env.auto"; \
	'

.PHONY: env-show
env-show: ## 現在の環境変数を表示
	@echo "📊 現在の環境変数:"
	@echo ""
	@echo "=== AWS ==="
	@echo "AWS_PROFILE: $$AWS_PROFILE"
	@echo "AWS_REGION: $$AWS_REGION"
	@echo ""
	@echo "=== RDS ==="
	@echo "RDS_POSTGRES_ENDPOINT: $$RDS_POSTGRES_ENDPOINT"
	@echo "RDS_MYSQL_ENDPOINT: $$RDS_MYSQL_ENDPOINT"
	@echo ""
	@echo "=== SQS ==="
	@echo "TO_WEB_QUEUE_URL: $$TO_WEB_QUEUE_URL"
	@echo "TO_MC_QUEUE_URL: $$TO_MC_QUEUE_URL"
	@echo "TO_DISCORD_QUEUE_URL: $$TO_DISCORD_QUEUE_URL"
	@echo ""
	@echo "=== S3 ==="
	@echo "S3_BUCKET: $$S3_BUCKET"
	@echo "S3_IMAGE_MAPS_BUCKET: $$S3_IMAGE_MAPS_BUCKET"
	@echo "S3_WORLD_BACKUPS_BUCKET: $$S3_WORLD_BACKUPS_BUCKET"
	@echo ""
	@echo "=== EC2 ==="
	@echo "INSTANCE_ID_A (MC): $$INSTANCE_ID_A"
	@echo "INSTANCE_ID_B (API): $$INSTANCE_ID_B"
	@echo "INSTANCE_ID_C (Web): $$INSTANCE_ID_C"
	@echo "INSTANCE_ID_D (Jump): $$INSTANCE_ID_D"
	@echo ""
	@echo "=== Private IPs ==="
	@echo "INSTANCE_ID_A_PRIVATE_IP: $$INSTANCE_ID_A_PRIVATE_IP"
	@echo "INSTANCE_ID_B_PRIVATE_IP: $$INSTANCE_ID_B_PRIVATE_IP"
	@echo "INSTANCE_ID_C_PRIVATE_IP: $$INSTANCE_ID_C_PRIVATE_IP"

## =============================================================================
## AWS認証
## =============================================================================

.PHONY: login
login: ## AWS SSOログイン
	@echo "🔐 AWS SSOログイン中..."
	aws sso login --profile $(AWS_PROFILE)

.PHONY: whoami
whoami: ## 現在のAWS認証情報を確認
	@echo "👤 現在のAWS認証情報:"
	aws sts get-caller-identity --profile $(AWS_PROFILE)

## =============================================================================
## Git関連
## =============================================================================

.PHONY: sync
sync: ## Gitサブモジュールを最新に同期
	@echo "🔄 Gitサブモジュール同期中..."
	git submodule update --remote --merge

.PHONY: submodule-init
submodule-init: ## Gitサブモジュールを初期化
	@echo "🔧 Gitサブモジュール初期化中..."
	git submodule update --init --recursive

## =============================================================================
## Terraform
## =============================================================================

.PHONY: tf-init
tf-init: ## Terraformを初期化
	@echo "🔧 Terraform初期化中..."
	cd terraform && terraform init

.PHONY: tf-plan
tf-plan: ## Terraformプランを生成
	@echo "📝 Terraformプラン生成中..."
	cd terraform && terraform plan -out=tfplan

.PHONY: tf-apply
tf-apply: ## Terraformプランを適用
	@echo "🚀 Terraformプラン適用中..."
	cd terraform && terraform apply tfplan

.PHONY: tf-apply-auto
tf-apply-auto: ## Terraformプランを自動承認で適用
	@echo "🚀 Terraformプラン適用中（自動承認）..."
	cd terraform && terraform apply -auto-approve

.PHONY: tf-destroy
tf-destroy: ## Terraformリソースを削除
	@echo "⚠️  Terraformリソース削除中..."
	@read -p "本当に削除しますか？ [y/N]: " confirm && [ "$$confirm" = "y" ] || exit 1
	cd terraform && terraform destroy

.PHONY: tf-output
tf-output: ## Terraform出力を表示
	@echo "📊 Terraform出力:"
	cd terraform && terraform output

.PHONY: tf-fmt
tf-fmt: ## Terraformファイルをフォーマット
	@echo "✨ Terraformファイルフォーマット中..."
	cd terraform && terraform fmt -recursive

.PHONY: tf-validate
tf-validate: ## Terraformファイルを検証
	@echo "✅ Terraformファイル検証中..."
	cd terraform && terraform validate

## =============================================================================
## EC2管理
## =============================================================================

.PHONY: ec2-list
ec2-list: ## EC2インスタンス一覧を表示
	@echo "📋 EC2インスタンス一覧:"
	aws ec2 describe-instances \
		--profile $(AWS_PROFILE) \
		--query 'Reservations[*].Instances[*].[Tags[?Key==`Name`].Value|[0],InstanceId,InstanceType,State.Name,PublicIpAddress,PrivateIpAddress]' \
		--output table

.PHONY: ec2-connect-api
ec2-connect-api: ## i-b (API Server)にSSM接続
	@echo "🔗 i-b (API Server)に接続中..."
	@INSTANCE_ID=$$(cd terraform && terraform output -raw api_server_id 2>/dev/null); \
	if [ -z "$$INSTANCE_ID" ]; then \
		echo "❌ API ServerのインスタンスIDが取得できませんでした"; \
		exit 1; \
	fi; \
	aws ssm start-session --target $$INSTANCE_ID --profile $(AWS_PROFILE)

.PHONY: ec2-connect-web
ec2-connect-web: ## i-c (Web Server)にSSM接続
	@echo "🔗 i-c (Web Server)に接続中..."
	@INSTANCE_ID=$$(cd terraform && terraform output -raw web_server_id 2>/dev/null); \
	if [ -z "$$INSTANCE_ID" ]; then \
		echo "❌ Web ServerのインスタンスIDが取得できませんでした"; \
		exit 1; \
	fi; \
	aws ssm start-session --target $$INSTANCE_ID --profile $(AWS_PROFILE)

.PHONY: ec2-connect-mc
ec2-connect-mc: ## i-a (MC Server)にSSM接続
	@echo "🔗 i-a (MC Server)に接続中..."
	@INSTANCE_ID=$$(cd terraform && terraform output -raw mc_server_id 2>/dev/null); \
	if [ -z "$$INSTANCE_ID" ]; then \
		echo "❌ MC ServerのインスタンスIDが取得できませんでした"; \
		exit 1; \
	fi; \
	aws ssm start-session --target $$INSTANCE_ID --profile $(AWS_PROFILE)

.PHONY: ec2-connect-jump
ec2-connect-jump: ## i-d (Jump Server)にSSM接続
	@echo "🔗 i-d (Jump Server)に接続中..."
	@INSTANCE_ID=$$(cd terraform && terraform output -raw jump_server_id 2>/dev/null); \
	if [ -z "$$INSTANCE_ID" ]; then \
		echo "❌ Jump ServerのインスタンスIDが取得できませんでした"; \
		exit 1; \
	fi; \
	aws ssm start-session --target $$INSTANCE_ID --profile $(AWS_PROFILE)

.PHONY: ec2-start-mc
ec2-start-mc: ## i-a (MC Server)を起動
	@echo "▶️  i-a (MC Server)起動中..."
	@INSTANCE_ID=$$(cd terraform && terraform output -raw mc_server_id 2>/dev/null); \
	aws ec2 start-instances --instance-ids $$INSTANCE_ID --profile $(AWS_PROFILE)

.PHONY: ec2-stop-mc
ec2-stop-mc: ## i-a (MC Server)を停止
	@echo "⏹️  i-a (MC Server)停止中..."
	@INSTANCE_ID=$$(cd terraform && terraform output -raw mc_server_id 2>/dev/null); \
	aws ec2 stop-instances --instance-ids $$INSTANCE_ID --profile $(AWS_PROFILE)

.PHONY: ec2-start-jump
ec2-start-jump: ## i-d (Jump Server)を起動
	@echo "▶️  i-d (Jump Server)起動中..."
	@INSTANCE_ID=$$(cd terraform && terraform output -raw jump_server_id 2>/dev/null); \
	aws ec2 start-instances --instance-ids $$INSTANCE_ID --profile $(AWS_PROFILE)

.PHONY: ec2-stop-jump
ec2-stop-jump: ## i-d (Jump Server)を停止
	@echo "⏹️  i-d (Jump Server)停止中..."
	@INSTANCE_ID=$$(cd terraform && terraform output -raw jump_server_id 2>/dev/null); \
	aws ec2 stop-instances --instance-ids $$INSTANCE_ID --profile $(AWS_PROFILE)

## =============================================================================
## SSM接続（ポートフォワーディング - このターミナルを占有）
## =============================================================================

.PHONY: ssm-mc ssm-api ssm-web ssm-jump ssm-mysql ssm-postgres

ssm-mc: ## i-a (MC Server) へポートフォワーディング (localhost:2222)
	@echo "🔗 MC Server (i-a) へポートフォワーディングを開始します..."
	@INSTANCE_ID_D=$$(aws ec2 describe-instances --profile $(AWS_PROFILE) --region $(AWS_REGION) \
		--filters "Name=tag:Name,Values=kishax-$(ENVIRONMENT)-jump-server" "Name=instance-state-name,Values=running" \
		--query 'Reservations[0].Instances[0].InstanceId' --output text 2>/dev/null); \
	PRIVATE_IP_A=$$(aws ec2 describe-instances --profile $(AWS_PROFILE) --region $(AWS_REGION) \
		--filters "Name=tag:Name,Values=kishax-$(ENVIRONMENT)-mc-server" \
		--query 'Reservations[0].Instances[0].PrivateIpAddress' --output text 2>/dev/null); \
	if [ -z "$$INSTANCE_ID_D" ] || [ "$$INSTANCE_ID_D" = "None" ]; then \
		echo "❌ Jump Serverが起動していません"; \
		exit 1; \
	fi; \
	if [ -z "$$PRIVATE_IP_A" ] || [ "$$PRIVATE_IP_A" = "None" ]; then \
		echo "❌ MC Serverが見つかりません"; \
		exit 1; \
	fi; \
	echo "Jump Server: $$INSTANCE_ID_D"; \
	echo "Target: $$PRIVATE_IP_A (MC Server)"; \
	echo "Local Port: 2222"; \
	echo ""; \
	echo "✅ ポートフォワーディング開始 (このターミナルは占有されます)"; \
	echo "📝 別ターミナルで 'make ssh-mc' を実行してSSH接続してください"; \
	echo ""; \
	aws ssm start-session \
		--target $$INSTANCE_ID_D \
		--document-name AWS-StartPortForwardingSessionToRemoteHost \
		--parameters "{\"host\":[\"$$PRIVATE_IP_A\"],\"portNumber\":[\"22\"],\"localPortNumber\":[\"2222\"]}" \
		--profile $(AWS_PROFILE)

ssm-api: ## i-b (API Server) へポートフォワーディング (localhost:2223)
	@echo "🔗 API Server (i-b) へポートフォワーディングを開始します..."
	@INSTANCE_ID_D=$$(aws ec2 describe-instances --profile $(AWS_PROFILE) --region $(AWS_REGION) \
		--filters "Name=tag:Name,Values=kishax-$(ENVIRONMENT)-jump-server" "Name=instance-state-name,Values=running" \
		--query 'Reservations[0].Instances[0].InstanceId' --output text 2>/dev/null); \
	PRIVATE_IP_B=$$(aws ec2 describe-instances --profile $(AWS_PROFILE) --region $(AWS_REGION) \
		--filters "Name=tag:Name,Values=kishax-$(ENVIRONMENT)-api-server" \
		--query 'Reservations[0].Instances[0].PrivateIpAddress' --output text 2>/dev/null); \
	if [ -z "$$INSTANCE_ID_D" ] || [ "$$INSTANCE_ID_D" = "None" ]; then \
		echo "❌ Jump Serverが起動していません"; \
		exit 1; \
	fi; \
	if [ -z "$$PRIVATE_IP_B" ] || [ "$$PRIVATE_IP_B" = "None" ]; then \
		echo "❌ API Serverが見つかりません"; \
		exit 1; \
	fi; \
	echo "Jump Server: $$INSTANCE_ID_D"; \
	echo "Target: $$PRIVATE_IP_B (API Server)"; \
	echo "Local Port: 2223"; \
	echo ""; \
	echo "✅ ポートフォワーディング開始 (このターミナルは占有されます)"; \
	echo "📝 別ターミナルで 'make ssh-api' を実行してSSH接続してください"; \
	echo ""; \
	aws ssm start-session \
		--target $$INSTANCE_ID_D \
		--document-name AWS-StartPortForwardingSessionToRemoteHost \
		--parameters "{\"host\":[\"$$PRIVATE_IP_B\"],\"portNumber\":[\"22\"],\"localPortNumber\":[\"2223\"]}" \
		--profile $(AWS_PROFILE)

ssm-web: ## i-c (Web Server) へポートフォワーディング (localhost:2224)
	@echo "🔗 Web Server (i-c) へポートフォワーディングを開始します..."
	@INSTANCE_ID_D=$$(aws ec2 describe-instances --profile $(AWS_PROFILE) --region $(AWS_REGION) \
		--filters "Name=tag:Name,Values=kishax-$(ENVIRONMENT)-jump-server" "Name=instance-state-name,Values=running" \
		--query 'Reservations[0].Instances[0].InstanceId' --output text 2>/dev/null); \
	PRIVATE_IP_C=$$(aws ec2 describe-instances --profile $(AWS_PROFILE) --region $(AWS_REGION) \
		--filters "Name=tag:Name,Values=kishax-$(ENVIRONMENT)-web-server" \
		--query 'Reservations[0].Instances[0].PrivateIpAddress' --output text 2>/dev/null); \
	if [ -z "$$INSTANCE_ID_D" ] || [ "$$INSTANCE_ID_D" = "None" ]; then \
		echo "❌ Jump Serverが起動していません"; \
		exit 1; \
	fi; \
	if [ -z "$$PRIVATE_IP_C" ] || [ "$$PRIVATE_IP_C" = "None" ]; then \
		echo "❌ Web Serverが見つかりません"; \
		exit 1; \
	fi; \
	echo "Jump Server: $$INSTANCE_ID_D"; \
	echo "Target: $$PRIVATE_IP_C (Web Server)"; \
	echo "Local Port: 2224"; \
	echo ""; \
	echo "✅ ポートフォワーディング開始 (このターミナルは占有されます)"; \
	echo "📝 別ターミナルで 'make ssh-web' を実行してSSH接続してください"; \
	echo ""; \
	aws ssm start-session \
		--target $$INSTANCE_ID_D \
		--document-name AWS-StartPortForwardingSessionToRemoteHost \
		--parameters "{\"host\":[\"$$PRIVATE_IP_C\"],\"portNumber\":[\"22\"],\"localPortNumber\":[\"2224\"]}" \
		--profile $(AWS_PROFILE)

ssm-jump: ## i-d (Jump Server) へSSM直接接続
	@echo "🔗 Jump Server (i-d) へSSMセッションを開始します..."
	@INSTANCE_ID=$$(aws ec2 describe-instances --profile $(AWS_PROFILE) --region $(AWS_REGION) \
		--filters "Name=tag:Name,Values=kishax-$(ENVIRONMENT)-jump-server" "Name=instance-state-name,Values=running" \
		--query 'Reservations[0].Instances[0].InstanceId' --output text 2>/dev/null); \
	if [ -z "$$INSTANCE_ID" ] || [ "$$INSTANCE_ID" = "None" ]; then \
		echo "❌ Jump Serverが起動していません"; \
		exit 1; \
	fi; \
	echo "Instance ID: $$INSTANCE_ID"; \
	echo ""; \
	aws ssm start-session --target $$INSTANCE_ID --profile $(AWS_PROFILE)

ssm-mysql: ## RDS MySQL へポートフォワーディング (localhost:3307)
	@echo "🔗 RDS MySQL へポートフォワーディングを開始します..."
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	source .env.auto; \
	if [ -z "$$RDS_MYSQL_HOST" ]; then \
		echo "❌ RDS_MYSQL_HOSTが設定されていません"; \
		exit 1; \
	fi; \
	INSTANCE_ID_D=$$(aws ec2 describe-instances --profile $(AWS_PROFILE) --region $(AWS_REGION) \
		--filters "Name=tag:Name,Values=kishax-$(ENVIRONMENT)-jump-server" "Name=instance-state-name,Values=running" \
		--query 'Reservations[0].Instances[0].InstanceId' --output text 2>/dev/null); \
	if [ -z "$$INSTANCE_ID_D" ] || [ "$$INSTANCE_ID_D" = "None" ]; then \
		echo "❌ Jump Serverが起動していません"; \
		exit 1; \
	fi; \
	echo "Jump Server: $$INSTANCE_ID_D"; \
	echo "Target: $$RDS_MYSQL_HOST:$$RDS_MYSQL_PORT"; \
	echo "Local Port: 3307"; \
	echo "Database: kishax_mc"; \
	echo ""; \
	echo "✅ ポートフォワーディング開始 (このターミナルは占有されます)"; \
	echo "📝 別ターミナルで 'make ssh-mysql' を実行してMySQL接続してください"; \
	echo ""; \
	aws ssm start-session \
		--target $$INSTANCE_ID_D \
		--document-name AWS-StartPortForwardingSessionToRemoteHost \
		--parameters "{\"host\":[\"$$RDS_MYSQL_HOST\"],\"portNumber\":[\"$$RDS_MYSQL_PORT\"],\"localPortNumber\":[\"3307\"]}" \
		--profile $(AWS_PROFILE)

ssm-postgres: ## RDS PostgreSQL へポートフォワーディング (localhost:5433)
	@echo "🔗 RDS PostgreSQL へポートフォワーディングを開始します..."
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	source .env.auto; \
	if [ -z "$$RDS_POSTGRES_HOST" ]; then \
		echo "❌ RDS_POSTGRES_HOSTが設定されていません"; \
		exit 1; \
	fi; \
	INSTANCE_ID_D=$$(aws ec2 describe-instances --profile $(AWS_PROFILE) --region $(AWS_REGION) \
		--filters "Name=tag:Name,Values=kishax-$(ENVIRONMENT)-jump-server" "Name=instance-state-name,Values=running" \
		--query 'Reservations[0].Instances[0].InstanceId' --output text 2>/dev/null); \
	if [ -z "$$INSTANCE_ID_D" ] || [ "$$INSTANCE_ID_D" = "None" ]; then \
		echo "❌ Jump Serverが起動していません"; \
		exit 1; \
	fi; \
	echo "Jump Server: $$INSTANCE_ID_D"; \
	echo "Target: $$RDS_POSTGRES_HOST:$$RDS_POSTGRES_PORT"; \
	echo "Local Port: 5433"; \
	echo "Database: kishax_web"; \
	echo ""; \
	echo "✅ ポートフォワーディング開始 (このターミナルは占有されます)"; \
	echo "📝 別ターミナルで 'make ssh-postgres' を実行してPostgreSQL接続してください"; \
	echo ""; \
	aws ssm start-session \
		--target $$INSTANCE_ID_D \
		--document-name AWS-StartPortForwardingSessionToRemoteHost \
		--parameters "{\"host\":[\"$$RDS_POSTGRES_HOST\"],\"portNumber\":[\"$$RDS_POSTGRES_PORT\"],\"localPortNumber\":[\"5433\"]}" \
		--profile $(AWS_PROFILE)

## =============================================================================
## SSH接続（純粋なSSH - 事前に ssm-* でポートフォワーディングが必要）
## =============================================================================

.PHONY: ssh-mc ssh-api ssh-web ssh-mysql ssh-postgres

ssh-mc: ## i-a (MC Server) へSSH接続 (要: 別ターミナルで make ssm-mc)
	@echo "🔗 MC Server (i-a) へSSH接続します..."
	@if [ ! -f "$(SSH_KEY)" ]; then \
		echo "❌ SSH鍵ファイルが見つかりません: $(SSH_KEY)"; \
		exit 1; \
	fi; \
	echo "SSH Key: $(SSH_KEY)"; \
	echo "Local Port: 2222"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-mc' を実行してください"; \
	echo ""; \
	if grep -q "\[localhost\]:2222" ~/.ssh/known_hosts 2>/dev/null; then \
		echo "⚠️  known_hostsに[localhost]:2222のエントリが存在します"; \
		read -p "削除しますか？ (y/N): " answer; \
		if [ "$$answer" = "y" ] || [ "$$answer" = "Y" ]; then \
			ssh-keygen -R "[localhost]:2222" 2>/dev/null || true; \
			echo "✅ known_hostsから削除しました"; \
		fi; \
	fi; \
	ssh -i $(SSH_KEY) -p 2222 ec2-user@localhost

ssh-api: ## i-b (API Server) へSSH接続 (要: 別ターミナルで make ssm-api)
	@echo "🔗 API Server (i-b) へSSH接続します..."
	@if [ ! -f "$(SSH_KEY)" ]; then \
		echo "❌ SSH鍵ファイルが見つかりません: $(SSH_KEY)"; \
		exit 1; \
	fi; \
	echo "SSH Key: $(SSH_KEY)"; \
	echo "Local Port: 2223"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-api' を実行してください"; \
	echo ""; \
	if grep -q "\[localhost\]:2223" ~/.ssh/known_hosts 2>/dev/null; then \
		echo "⚠️  known_hostsに[localhost]:2223のエントリが存在します"; \
		read -p "削除しますか？ (y/N): " answer; \
		if [ "$$answer" = "y" ] || [ "$$answer" = "Y" ]; then \
			ssh-keygen -R "[localhost]:2223" 2>/dev/null || true; \
			echo "✅ known_hostsから削除しました"; \
		fi; \
	fi; \
	ssh -i $(SSH_KEY) -p 2223 ec2-user@localhost

ssh-web: ## i-c (Web Server) へSSH接続 (要: 別ターミナルで make ssm-web)
	@echo "🔗 Web Server (i-c) へSSH接続します..."
	@if [ ! -f "$(SSH_KEY)" ]; then \
		echo "❌ SSH鍵ファイルが見つかりません: $(SSH_KEY)"; \
		exit 1; \
	fi; \
	echo "SSH Key: $(SSH_KEY)"; \
	echo "Local Port: 2224"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-web' を実行してください"; \
	echo ""; \
	if grep -q "\[localhost\]:2224" ~/.ssh/known_hosts 2>/dev/null; then \
		echo "⚠️  known_hostsに[localhost]:2224のエントリが存在します"; \
		read -p "削除しますか？ (y/N): " answer; \
		if [ "$$answer" = "y" ] || [ "$$answer" = "Y" ]; then \
			ssh-keygen -R "[localhost]:2224" 2>/dev/null || true; \
			echo "✅ known_hostsから削除しました"; \
		fi; \
	fi; \
	ssh -i $(SSH_KEY) -p 2224 ec2-user@localhost

ssh-mysql: ## RDS MySQL へMySQL接続 (要: 別ターミナルで make ssm-mysql)
	@echo "🔗 RDS MySQL へMySQL接続します..."
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	source .env && source .env.auto; \
	if [ -z "$$MYSQL_PASSWORD" ]; then \
		echo "❌ MYSQL_PASSWORDが設定されていません"; \
		exit 1; \
	fi; \
	MYSQL_USER=$${MYSQL_USER:-root}; \
	echo "Database: kishax_mc"; \
	echo "User: $$MYSQL_USER"; \
	echo "Host: localhost:3307"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-mysql' を実行してください"; \
	echo ""; \
	mysql -h 127.0.0.1 -P 3307 -u "$$MYSQL_USER" -p"$$MYSQL_PASSWORD" kishax_mc

ssh-postgres: ## RDS PostgreSQL へpsql接続 (要: 別ターミナルで make ssm-postgres)
	@echo "🔗 RDS PostgreSQL へpsql接続します..."
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	source .env && source .env.auto; \
	if [ -z "$$POSTGRES_PASSWORD" ]; then \
		echo "❌ POSTGRES_PASSWORDが設定されていません"; \
		exit 1; \
	fi; \
	POSTGRES_USER=$${POSTGRES_USER:-postgres}; \
	echo "Database: kishax_web"; \
	echo "User: $$POSTGRES_USER"; \
	echo "Host: localhost:5433"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-postgres' を実行してください"; \
	echo ""; \
	PGPASSWORD="$$POSTGRES_PASSWORD" psql -h 127.0.0.1 -p 5433 -U "$$POSTGRES_USER" -d kishax_web

## =============================================================================
## MySQL シード管理
## =============================================================================

.PHONY: mysql-seed-list mysql-seed-import mysql-seed-tables mysql-seed-s3 mysql-seed-all mysql-seed-reset mysql-seed-fix-db-names

mysql-seed-tables: ## MySQLテーブルを作成 (要: make ssm-mysql)
	@echo "🔧 MySQLテーブルを作成します"
	@echo ""
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	if [ ! -f .db/mc/TABLES.sql ]; then \
		echo "❌ .db/mc/TABLES.sql が見つかりません"; \
		exit 1; \
	fi; \
	source .env && source .env.auto; \
	if [ -z "$$MYSQL_PASSWORD" ]; then \
		echo "❌ MYSQL_PASSWORDが設定されていません"; \
		echo "💡 'source .env && source .env.auto' を実行してください"; \
		exit 1; \
	fi; \
	MYSQL_USER=$${MYSQL_USER:-root}; \
	echo "Database: kishax_mc"; \
	echo "User: $$MYSQL_USER"; \
	echo "Host: localhost:3307"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-mysql' を実行してください"; \
	echo ""; \
	read -p "テーブルを作成しますか？ (y/N): " answer; \
	if [ "$$answer" != "y" ] && [ "$$answer" != "Y" ]; then \
		echo "キャンセルしました"; \
		exit 0; \
	fi; \
	echo ""; \
	echo "🔧 テーブル作成中..."; \
	mysql -h 127.0.0.1 -P 3307 -u "$$MYSQL_USER" -p"$$MYSQL_PASSWORD" kishax_mc < .db/mc/TABLES.sql 2>&1 | grep -v "Using a password on the command line" || true; \
	if [ $$? -eq 0 ]; then \
		echo "✅ テーブルを作成しました"; \
	else \
		echo "❌ テーブル作成に失敗しました"; \
		exit 1; \
	fi

mysql-seed-list: ## .db/mc のシードファイル一覧を表示
	@echo "📋 MySQLシードファイル一覧:"
	@echo ""
	@if [ -d .db/mc ]; then \
		ls -lh .db/mc/*.sql 2>/dev/null | awk '{print "  " $$9 " (" $$5 ")"}' || echo "  ファイルが見つかりません"; \
	else \
		echo "  ❌ .db/mc ディレクトリが存在しません"; \
	fi

mysql-seed-import: ## 指定したシードファイルをRDS MySQLに挿入 (要: make ssm-mysql)
	@echo "📥 MySQLシードファイルをインポートします"
	@echo ""
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	if [ -z "$(FILE)" ]; then \
		echo "❌ FILEパラメータを指定してください"; \
		echo ""; \
		echo "例: make mysql-seed-import FILE=.db/mc/s3_image_storage_settings_fixed.sql"; \
		echo ""; \
		$(MAKE) mysql-seed-list; \
		exit 1; \
	fi; \
	if [ ! -f "$(FILE)" ]; then \
		echo "❌ ファイルが見つかりません: $(FILE)"; \
		exit 1; \
	fi; \
	source .env && source .env.auto; \
	MYSQL_USER=$${MYSQL_USER:-root}; \
	echo "ファイル: $(FILE)"; \
	echo "Database: kishax_mc"; \
	echo "User: $$MYSQL_USER"; \
	echo "Host: localhost:3307"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-mysql' を実行してください"; \
	echo ""; \
	read -p "このファイルをインポートしますか？ (y/N): " answer; \
	if [ "$$answer" = "y" ] || [ "$$answer" = "Y" ]; then \
		ERROR_OUTPUT=$$(mysql -h 127.0.0.1 -P 3307 -u "$$MYSQL_USER" -p"$$MYSQL_PASSWORD" kishax_mc < "$(FILE)" 2>&1 | grep -v "Using a password on the command line"); \
		if [ -z "$$ERROR_OUTPUT" ]; then \
			echo ""; \
			echo "✅ インポート完了"; \
		else \
			echo ""; \
			echo "❌ インポートに失敗しました"; \
			echo "📝 エラー: $$ERROR_OUTPUT"; \
			exit 1; \
		fi; \
	else \
		echo "キャンセルしました"; \
	fi

mysql-seed-s3: ## S3画像ストレージ設定をインポート (要: make ssm-mysql)
	@$(MAKE) mysql-seed-import FILE=.db/mc/s3_image_storage_settings_fixed.sql

mysql-seed-fix-db-names: ## .db/mc のSQLファイルのデータベース名を修正 (mc. -> kishax_mc.)
	@echo "🔧 データベース名を修正します (mc. -> kishax_mc.)"
	@echo ""
	@if [ ! -d .db/mc ]; then \
		echo "❌ .db/mc ディレクトリが存在しません"; \
		exit 1; \
	fi; \
	echo "📋 修正対象ファイル:"; \
	for file in .db/mc/*.sql; do \
		if [ -f "$$file" ] && ! echo "$$file" | grep -q "_fixed.sql"; then \
			if grep -q "INSERT INTO mc\." "$$file" 2>/dev/null; then \
				echo "  - $$(basename $$file)"; \
			fi; \
		fi; \
	done; \
	echo ""; \
	read -p "データベース名を修正しますか？ (y/N): " answer; \
	if [ "$$answer" != "y" ] && [ "$$answer" != "Y" ]; then \
		echo "キャンセルしました"; \
		exit 0; \
	fi; \
	echo ""; \
	echo "🔧 修正中..."; \
	SUCCESS_COUNT=0; \
	for file in .db/mc/*.sql; do \
		if [ -f "$$file" ] && ! echo "$$file" | grep -q "_fixed.sql"; then \
			FILE_NAME=$$(basename "$$file"); \
			if grep -q "INSERT INTO mc\." "$$file" 2>/dev/null; then \
				sed 's/INSERT INTO mc\./INSERT INTO kishax_mc./g' "$$file" > "$${file%.sql}_fixed.sql"; \
				if [ -f "$${file%.sql}_fixed.sql" ]; then \
					echo "  ✅ $$FILE_NAME -> $${FILE_NAME%.sql}_fixed.sql"; \
					SUCCESS_COUNT=$$((SUCCESS_COUNT + 1)); \
				fi; \
			fi; \
		fi; \
	done; \
	echo ""; \
	echo "✅ $$SUCCESS_COUNT ファイルを修正しました"; \
	echo "💡 修正されたファイルは *_fixed.sql として保存されています"

mysql-seed-reset: ## kishax_mc データベースの全テーブルを削除 (要: make ssm-mysql)
	@echo "🗑️  MySQL データベースをリセットします"
	@echo ""
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	source .env && source .env.auto; \
	MYSQL_USER=$${MYSQL_USER:-root}; \
	echo "Database: kishax_mc"; \
	echo "User: $$MYSQL_USER"; \
	echo "Host: localhost:3307"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-mysql' を実行してください"; \
	echo "⚠️  警告: 全てのテーブルとデータが削除されます！"; \
	echo ""; \
	read -p "本当に削除しますか？ (yes/N): " answer; \
	if [ "$$answer" != "yes" ]; then \
		echo "キャンセルしました"; \
		exit 0; \
	fi; \
	echo ""; \
	echo "🗑️  テーブル削除中..."; \
	mysql -h 127.0.0.1 -P 3307 -u "$$MYSQL_USER" -p"$$MYSQL_PASSWORD" kishax_mc -e " \
		SET FOREIGN_KEY_CHECKS = 0; \
		SET @tables = NULL; \
		SELECT GROUP_CONCAT(table_name) INTO @tables \
		  FROM information_schema.tables \
		  WHERE table_schema = 'kishax_mc'; \
		SET @tables = CONCAT('DROP TABLE IF EXISTS ', @tables); \
		PREPARE stmt FROM @tables; \
		EXECUTE stmt; \
		DEALLOCATE PREPARE stmt; \
		SET FOREIGN_KEY_CHECKS = 1; \
	" 2>/dev/null; \
	echo ""; \
	echo "✅ データベースをリセットしました"; \
	echo "💡 次のステップ:"; \
	echo "   1. make mysql-seed-tables  # テーブルを再作成"; \
	echo "   2. make mysql-seed-all     # シードデータをインポート"

mysql-seed-all: ## .db/mc の全シードファイルを一括インポート (要: make ssm-mysql)
	@echo "📥 MySQL 全シードファイルを一括インポートします"
	@echo ""
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	if [ ! -d .db/mc ]; then \
		echo "❌ .db/mc ディレクトリが存在しません"; \
		exit 1; \
	fi; \
	FILE_COUNT=$$(ls -1 .db/mc/*_fixed.sql 2>/dev/null | wc -l | tr -d ' '); \
	if [ "$$FILE_COUNT" -eq 0 ]; then \
		echo "❌ .db/mc に*_fixed.sqlファイルが見つかりません"; \
		echo "💡 'make mysql-seed-fix-db-names' を先に実行してください"; \
		exit 1; \
	fi; \
	source .env && source .env.auto; \
	if [ -z "$$MYSQL_PASSWORD" ]; then \
		echo "❌ MYSQL_PASSWORDが設定されていません"; \
		echo "💡 'source .env && source .env.auto' を実行してください"; \
		exit 1; \
	fi; \
	MYSQL_USER=$${MYSQL_USER:-root}; \
	echo "対象ファイル数: $$FILE_COUNT"; \
	echo "Database: kishax_mc"; \
	echo "Host: localhost:3307"; \
	echo "User: $$MYSQL_USER"; \
	echo "Password length: $${#MYSQL_PASSWORD}"; \
	echo ""; \
	echo "🔍 MySQL接続確認中..."; \
	TABLE_COUNT=$$(mysql -h 127.0.0.1 -P 3307 -u "$$MYSQL_USER" -p"$$MYSQL_PASSWORD" kishax_mc -e "SHOW TABLES;" 2>&1 | grep -v "Using a password" | grep -v "Tables_in" | wc -l | tr -d ' '); \
	if [ "$$TABLE_COUNT" -eq 0 ]; then \
		echo "⚠️  テーブルが存在しません。先にテーブルを作成します..."; \
		$(MAKE) mysql-seed-tables; \
	fi; \
	CONNECTION_TEST=$$(mysql -h 127.0.0.1 -P 3307 -u "$$MYSQL_USER" -p"$$MYSQL_PASSWORD" -e "SELECT 1" kishax_mc 2>&1 | grep -v "Using a password on the command line"); \
	if [ $$? -ne 0 ] || echo "$$CONNECTION_TEST" | grep -q "ERROR"; then \
		echo "❌ MySQLに接続できません"; \
		echo ""; \
		echo "📝 エラー詳細:"; \
		echo "$$CONNECTION_TEST" | head -n 3; \
		echo ""; \
		echo "💡 解決方法:"; \
		echo "   1. 別ターミナルで 'make ssm-mysql' を実行してください"; \
		echo "   2. ポートフォワーディングが正常に開始されるまで待ちます"; \
		echo "      ('Port 3307 opened' メッセージを確認)"; \
		echo "   3. このターミナルで 'source .env && source .env.auto' を実行"; \
		echo "   4. 再度このコマンドを実行してください"; \
		echo ""; \
		echo "🔍 デバッグ情報:"; \
		echo "   - ポート確認: lsof -i :3307"; \
		echo "   - 手動接続: mysql -h 127.0.0.1 -P 3307 -u $$MYSQL_USER -p kishax_mc"; \
		echo ""; \
		exit 1; \
	fi; \
	echo "✅ MySQL接続成功"; \
	echo ""; \
	echo "📋 対象ファイル一覧:"; \
	ls -1h .db/mc/*_fixed.sql | while read file; do \
		SIZE=$$(ls -lh "$$file" | awk '{print $$5}'); \
		echo "  - $$(basename $$file) ($$SIZE)"; \
	done; \
	echo ""; \
	echo "⚠️  大きなファイルがある場合、時間がかかる可能性があります"; \
	echo ""; \
	read -p "全てのファイルをインポートしますか？ (y/N): " answer; \
	if [ "$$answer" != "y" ] && [ "$$answer" != "Y" ]; then \
		echo "キャンセルしました"; \
		exit 0; \
	fi; \
	echo ""; \
	echo "🚀 インポート開始..."; \
	echo ""; \
	SUCCESS_COUNT=0; \
	FAIL_COUNT=0; \
	FAILED_FILES=""; \
	for sql_file in .db/mc/*_fixed.sql; do \
		if [ -f "$$sql_file" ]; then \
			FILE_NAME=$$(basename "$$sql_file"); \
			FILE_SIZE=$$(ls -lh "$$sql_file" | awk '{print $$5}'); \
			echo "📄 [$$((SUCCESS_COUNT + FAIL_COUNT + 1))/$$FILE_COUNT] $$FILE_NAME ($$FILE_SIZE)..."; \
			ERROR_MSG=$$(mysql -h 127.0.0.1 -P 3307 -u "$$MYSQL_USER" -p"$$MYSQL_PASSWORD" kishax_mc < "$$sql_file" 2>&1 | grep -v "Using a password on the command line"); \
			EXIT_CODE=$$?; \
			if [ $$EXIT_CODE -eq 0 ] && [ -z "$$ERROR_MSG" ]; then \
				echo "   ✅ 成功"; \
				SUCCESS_COUNT=$$((SUCCESS_COUNT + 1)); \
			else \
				if [ -n "$$ERROR_MSG" ]; then \
					echo "   ❌ 失敗"; \
					echo "   📝 エラー: $$(echo "$$ERROR_MSG" | head -n 1)"; \
					FAIL_COUNT=$$((FAIL_COUNT + 1)); \
					FAILED_FILES="$$FAILED_FILES  - $$FILE_NAME\n"; \
				else \
					echo "   ✅ 成功"; \
					SUCCESS_COUNT=$$((SUCCESS_COUNT + 1)); \
				fi; \
			fi; \
			echo ""; \
		fi; \
	done; \
	echo ""; \
	echo "========================================"; \
	echo "📊 インポート結果"; \
	echo "========================================"; \
	echo "✅ 成功: $$SUCCESS_COUNT / $$FILE_COUNT"; \
	echo "❌ 失敗: $$FAIL_COUNT / $$FILE_COUNT"; \
	echo "========================================"; \
	if [ $$FAIL_COUNT -gt 0 ]; then \
		echo ""; \
		echo "⚠️  失敗したファイル:"; \
		echo -e "$$FAILED_FILES"; \
		echo "💡 個別に確認するには:"; \
		echo "   make mysql-seed-import FILE=.db/mc/[ファイル名]"; \
	fi

## =============================================================================
## PostgreSQL シード管理
## =============================================================================

.PHONY: postgres-create-db postgres-seed-tables postgres-seed-list postgres-seed-import postgres-seed-users postgres-seed-all postgres-seed-reset

postgres-create-db: ## PostgreSQLデータベース (kishax_web) を作成 (要: make ssm-postgres)
	@echo "🔧 PostgreSQLデータベースを作成します"
	@echo ""
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	source .env && source .env.auto; \
	if [ -z "$$POSTGRES_PASSWORD" ]; then \
		echo "❌ POSTGRES_PASSWORDが設定されていません"; \
		exit 1; \
	fi; \
	POSTGRES_USER=$${POSTGRES_USER:-postgres}; \
	echo "Database: kishax_web"; \
	echo "User: $$POSTGRES_USER"; \
	echo "Host: localhost:5433"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-postgres' を実行してください"; \
	echo ""; \
	read -p "データベースを作成しますか？ (y/N): " answer; \
	if [ "$$answer" != "y" ] && [ "$$answer" != "Y" ]; then \
		echo "キャンセルしました"; \
		exit 0; \
	fi; \
	echo ""; \
	echo "🔧 データベース作成中..."; \
	PGPASSWORD="$$POSTGRES_PASSWORD" psql -h 127.0.0.1 -p 5433 -U "$$POSTGRES_USER" -d postgres -c "CREATE DATABASE kishax_web;" 2>&1 | grep -v "already exists" || true; \
	if [ $$? -eq 0 ]; then \
		echo "✅ データベースを作成しました（または既に存在します）"; \
	else \
		echo "❌ データベース作成に失敗しました"; \
		exit 1; \
	fi

postgres-seed-tables: ## PostgreSQLテーブルを作成 (Prisma migrate) (要: make ssm-postgres)
	@echo "🔧 PostgreSQLテーブルを作成します (Prisma)"
	@echo ""
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	if [ ! -d apps/web/prisma ]; then \
		echo "❌ apps/web/prisma ディレクトリが見つかりません"; \
		exit 1; \
	fi; \
	source .env && source .env.auto; \
	POSTGRES_USER=$${POSTGRES_USER:-postgres}; \
	echo "Database: kishax_web"; \
	echo "User: $$POSTGRES_USER"; \
	echo "Host: 127.0.0.1:5433"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-postgres' を実行してください"; \
	echo ""; \
	read -p "Prismaマイグレーションを実行しますか？ (y/N): " answer; \
	if [ "$$answer" != "y" ] && [ "$$answer" != "Y" ]; then \
		echo "キャンセルしました"; \
		exit 0; \
	fi; \
	echo ""; \
	echo "🔧 Prismaマイグレーション実行中..."; \
	ENCODED_PASSWORD=$$(python3 -c "import urllib.parse; print(urllib.parse.quote_plus('$$POSTGRES_PASSWORD'))"); \
	cd apps/web && DATABASE_URL="postgresql://$$POSTGRES_USER:$$ENCODED_PASSWORD@127.0.0.1:5433/kishax_web" npx prisma db push --skip-generate; \
	if [ $$? -eq 0 ]; then \
		echo "✅ テーブルを作成しました"; \
	else \
		echo "❌ テーブル作成に失敗しました"; \
		exit 1; \
	fi

postgres-seed-list: ## .db/web のシードファイル一覧を表示
	@echo "📋 PostgreSQLシードファイル一覧:"
	@echo ""
	@if [ -d .db/web ]; then \
		ls -lh .db/web/*.sql 2>/dev/null | awk '{print "  " $$9 " (" $$5 ")"}' || echo "  ファイルが見つかりません"; \
	else \
		echo "  ❌ .db/web ディレクトリが存在しません"; \
	fi

postgres-seed-import: ## 指定したシードファイルをRDS PostgreSQLに挿入 (要: make ssm-postgres)
	@echo "📥 PostgreSQLシードファイルをインポートします"
	@echo ""
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	if [ -z "$(FILE)" ]; then \
		echo "❌ FILEパラメータを指定してください"; \
		echo ""; \
		echo "例: make postgres-seed-import FILE=.db/web/users_migrated_seed.sql"; \
		echo ""; \
		$(MAKE) postgres-seed-list; \
		exit 1; \
	fi; \
	if [ ! -f "$(FILE)" ]; then \
		echo "❌ ファイルが見つかりません: $(FILE)"; \
		exit 1; \
	fi; \
	source .env && source .env.auto; \
	POSTGRES_USER=$${POSTGRES_USER:-postgres}; \
	echo "ファイル: $(FILE)"; \
	echo "Database: kishax_web"; \
	echo "User: $$POSTGRES_USER"; \
	echo "Host: localhost:5433"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-postgres' を実行してください"; \
	echo ""; \
	read -p "このファイルをインポートしますか？ (y/N): " answer; \
	if [ "$$answer" = "y" ] || [ "$$answer" = "Y" ]; then \
		PGPASSWORD="$$POSTGRES_PASSWORD" psql -h 127.0.0.1 -p 5433 -U "$$POSTGRES_USER" -d kishax_web -f "$(FILE)"; \
		echo ""; \
		echo "✅ インポート完了"; \
	else \
		echo "キャンセルしました"; \
	fi

postgres-seed-users: ## ユーザー情報をインポート (要: make ssm-postgres)
	@$(MAKE) postgres-seed-import FILE=.db/web/users_migrated_seed.sql

postgres-seed-reset: ## kishax_web データベースの全テーブルを削除 (要: make ssm-postgres)
	@echo "🗑️  PostgreSQL データベースをリセットします"
	@echo ""
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	source .env && source .env.auto; \
	POSTGRES_USER=$${POSTGRES_USER:-postgres}; \
	echo "Database: kishax_web"; \
	echo "User: $$POSTGRES_USER"; \
	echo "Host: localhost:5433"; \
	echo ""; \
	echo "⚠️  事前に別ターミナルで 'make ssm-postgres' を実行してください"; \
	echo "⚠️  警告: 全てのテーブルとデータが削除されます！"; \
	echo ""; \
	read -p "本当に削除しますか？ (yes/N): " answer; \
	if [ "$$answer" != "yes" ]; then \
		echo "キャンセルしました"; \
		exit 0; \
	fi; \
	echo ""; \
	echo "🗑️  テーブル削除中..."; \
	PGPASSWORD="$$POSTGRES_PASSWORD" psql -h 127.0.0.1 -p 5433 -U "$$POSTGRES_USER" -d kishax_web -c " \
		DO \$\$ DECLARE \
			r RECORD; \
		BEGIN \
			FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP \
				EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE'; \
			END LOOP; \
		END \$\$; \
	" 2>/dev/null; \
	echo ""; \
	echo "✅ データベースをリセットしました"; \
	echo "💡 テーブルを再作成するには、マイグレーションを実行してください"

postgres-seed-all: ## .db/web の全シードファイルを一括インポート + Prisma Migrate実行 (要: make ssm-postgres)
	@echo "📥 PostgreSQL 全シードファイルを一括インポートします"
	@echo ""
	@if [ ! -f .env.auto ]; then \
		echo "❌ .env.autoが見つかりません。'make env-load'を実行してください"; \
		exit 1; \
	fi; \
	if [ ! -d .db/web ]; then \
		echo "❌ .db/web ディレクトリが存在しません"; \
		exit 1; \
	fi; \
	FILE_COUNT=$$(ls -1 .db/web/*.sql 2>/dev/null | wc -l | tr -d ' '); \
	if [ "$$FILE_COUNT" -eq 0 ]; then \
		echo "❌ .db/web にSQLファイルが見つかりません"; \
		exit 1; \
	fi; \
	source .env && source .env.auto; \
	if [ -z "$$POSTGRES_PASSWORD" ]; then \
		echo "❌ POSTGRES_PASSWORDが設定されていません"; \
		echo "💡 'source .env && source .env.auto' を実行してください"; \
		exit 1; \
	fi; \
	POSTGRES_USER=$${POSTGRES_USER:-postgres}; \
	echo "対象ファイル数: $$FILE_COUNT"; \
	echo "Database: kishax_web"; \
	echo "Host: localhost:5433"; \
	echo "User: $$POSTGRES_USER"; \
	echo ""; \
	echo "🔍 PostgreSQL接続確認中..."; \
	CONNECTION_TEST=$$(PGPASSWORD="$$POSTGRES_PASSWORD" psql -h 127.0.0.1 -p 5433 -U "$$POSTGRES_USER" -d kishax_web -c "SELECT 1" 2>&1); \
	if [ $$? -ne 0 ]; then \
		echo "❌ PostgreSQLに接続できません"; \
		echo ""; \
		echo "📝 エラー詳細:"; \
		echo "$$CONNECTION_TEST" | head -n 3; \
		echo ""; \
		echo "💡 解決方法:"; \
		echo "   1. 別ターミナルで 'make ssm-postgres' を実行してください"; \
		echo "   2. ポートフォワーディングが正常に開始されるまで待ちます"; \
		echo "      ('Port 5433 opened' メッセージを確認)"; \
		echo "   3. このターミナルで 'source .env && source .env.auto' を実行"; \
		echo "   4. 再度このコマンドを実行してください"; \
		echo ""; \
		echo "🔍 デバッグ情報:"; \
		echo "   - ポート確認: lsof -i :5433"; \
		echo "   - 手動接続: PGPASSWORD=*** psql -h 127.0.0.1 -p 5433 -U $$POSTGRES_USER -d kishax_web"; \
		echo ""; \
		exit 1; \
	fi; \
	echo "✅ PostgreSQL接続成功"; \
	echo ""; \
	echo "🔄 Prisma Migrateを実行してスキーマを最新化します..."; \
	echo ""; \
	if [ -d apps/web ]; then \
		cd apps/web && DATABASE_URL="postgresql://$$POSTGRES_USER:$$POSTGRES_PASSWORD@127.0.0.1:5433/kishax_web?schema=public" npx prisma migrate deploy; \
		if [ $$? -eq 0 ]; then \
			echo "✅ Prisma Migrate完了"; \
		else \
			echo "❌ Prisma Migrateに失敗しました"; \
			exit 1; \
		fi; \
		cd ../..; \
	else \
		echo "⚠️  apps/web ディレクトリが見つかりません。Prisma Migrateをスキップします"; \
	fi; \
	echo ""; \
	echo "📋 対象ファイル一覧:"; \
	ls -1h .db/web/*.sql | while read file; do \
		FILE_NAME=$$(basename "$$file"); \
		if ! echo "$$FILE_NAME" | grep -q "^counter_"; then \
			SIZE=$$(ls -lh "$$file" | awk '{print $$5}'); \
			echo "  - $$FILE_NAME ($$SIZE)"; \
		fi; \
	done; \
	echo ""; \
	echo "💡 counter_*.sql はスキップされます（スキーマ互換性なし）"; \
	echo ""; \
	read -p "全てのファイルをインポートしますか？ (y/N): " answer; \
	if [ "$$answer" != "y" ] && [ "$$answer" != "Y" ]; then \
		echo "キャンセルしました"; \
		exit 0; \
	fi; \
	echo ""; \
	echo "🚀 インポート開始..."; \
	echo ""; \
	SUCCESS_COUNT=0; \
	FAIL_COUNT=0; \
	SKIP_COUNT=0; \
	FAILED_FILES=""; \
	for sql_file in .db/web/*.sql; do \
		if [ -f "$$sql_file" ]; then \
		FILE_NAME=$$(basename "$$sql_file"); \
		if echo "$$FILE_NAME" | grep -q "^counter_"; then \
			echo "⏭️  [$$((SUCCESS_COUNT + FAIL_COUNT + SKIP_COUNT + 1))/$$FILE_COUNT] $$FILE_NAME - スキップ (互換性なし)"; \
			SKIP_COUNT=$$((SKIP_COUNT + 1)); \
			echo ""; \
			continue; \
		fi; \
		FILE_SIZE=$$(ls -lh "$$sql_file" | awk '{print $$5}'); \
		echo "📄 [$$((SUCCESS_COUNT + FAIL_COUNT + SKIP_COUNT + 1))/$$FILE_COUNT] $$FILE_NAME ($$FILE_SIZE)..."; \
		ERROR_MSG=$$(PGPASSWORD="$$POSTGRES_PASSWORD" psql -h 127.0.0.1 -p 5433 -U "$$POSTGRES_USER" -d kishax_web -f "$$sql_file" 2>&1); \
			if [ $$? -eq 0 ]; then \
				echo "   ✅ 成功"; \
				SUCCESS_COUNT=$$((SUCCESS_COUNT + 1)); \
			else \
				echo "   ❌ 失敗"; \
				if [ -n "$$ERROR_MSG" ]; then \
					echo "   📝 エラー: $$(echo "$$ERROR_MSG" | head -n 1)"; \
				fi; \
				FAIL_COUNT=$$((FAIL_COUNT + 1)); \
				FAILED_FILES="$$FAILED_FILES  - $$FILE_NAME\n"; \
			fi; \
			echo ""; \
		fi; \
	done; \
	echo ""; \
	echo "========================================"; \
	echo "📊 インポート結果"; \
	echo "========================================"; \
	echo "✅ 成功: $$SUCCESS_COUNT / $$FILE_COUNT"; \
	echo "❌ 失敗: $$FAIL_COUNT / $$FILE_COUNT"; \
	echo "⏭️  スキップ: $$SKIP_COUNT / $$FILE_COUNT"; \
	echo "========================================"; \
	if [ $$FAIL_COUNT -gt 0 ]; then \
		echo ""; \
		echo "⚠️  失敗したファイル:"; \
		echo -e "$$FAILED_FILES"; \
		echo "💡 個別に確認するには:"; \
		echo "   make postgres-seed-import FILE=.db/web/[ファイル名]"; \
	fi; \
	if [ $$SKIP_COUNT -gt 0 ]; then \
		echo ""; \
		echo "💡 スキップされたファイルは互換性がないため除外されました"; \
	fi

## =============================================================================
## RDS管理
## =============================================================================

.PHONY: rds-status
rds-status: ## RDSインスタンスのステータス確認
	@echo "📊 RDSステータス:"
	aws rds describe-db-instances \
		--profile $(AWS_PROFILE) \
		--query 'DBInstances[*].[DBInstanceIdentifier,DBInstanceStatus,Engine,DBInstanceClass,Endpoint.Address]' \
		--output table

.PHONY: rds-connect-postgres
rds-connect-postgres: ## RDS PostgreSQLにポートフォワード接続
	@echo "🔗 RDS PostgreSQLに接続中（ローカルポート5433）..."
	@INSTANCE_ID=$$(cd terraform && terraform output -raw jump_server_id 2>/dev/null); \
	RDS_ENDPOINT=$$(cd terraform && terraform output -raw rds_postgres_endpoint 2>/dev/null); \
	aws ssm start-session \
		--target $$INSTANCE_ID \
		--document-name AWS-StartPortForwardingSessionToRemoteHost \
		--parameters "{\"portNumber\":[\"5432\"],\"localPortNumber\":[\"5433\"],\"host\":[\"$$RDS_ENDPOINT\"]}" \
		--profile $(AWS_PROFILE)

.PHONY: rds-connect-mysql
rds-connect-mysql: ## RDS MySQLにポートフォワード接続
	@echo "🔗 RDS MySQLに接続中（ローカルポート3307）..."
	@INSTANCE_ID=$$(cd terraform && terraform output -raw jump_server_id 2>/dev/null); \
	RDS_ENDPOINT=$$(cd terraform && terraform output -raw rds_mysql_endpoint 2>/dev/null); \
	aws ssm start-session \
		--target $$INSTANCE_ID \
		--document-name AWS-StartPortForwardingSessionToRemoteHost \
		--parameters "{\"portNumber\":[\"3306\"],\"localPortNumber\":[\"3307\"],\"host\":[\"$$RDS_ENDPOINT\"]}" \
		--profile $(AWS_PROFILE)

## =============================================================================
## SQS管理
## =============================================================================

.PHONY: sqs-list
sqs-list: ## SQSキュー一覧を表示
	@echo "📋 SQSキュー一覧:"
	aws sqs list-queues --profile $(AWS_PROFILE)

.PHONY: sqs-status
sqs-status: ## SQSキューのメッセージ数を確認
	@echo "📊 SQSキューのステータス:"
	@TO_WEB_QUEUE=$$(cd terraform && terraform output -raw to_web_queue_url 2>/dev/null); \
	TO_MC_QUEUE=$$(cd terraform && terraform output -raw to_mc_queue_url 2>/dev/null); \
	TO_DISCORD_QUEUE=$$(cd terraform && terraform output -raw to_discord_queue_url 2>/dev/null); \
	echo "To Web Queue:"; \
	aws sqs get-queue-attributes --queue-url $$TO_WEB_QUEUE --attribute-names ApproximateNumberOfMessages --profile $(AWS_PROFILE); \
	echo "To MC Queue:"; \
	aws sqs get-queue-attributes --queue-url $$TO_MC_QUEUE --attribute-names ApproximateNumberOfMessages --profile $(AWS_PROFILE); \
	echo "To Discord Queue:"; \
	aws sqs get-queue-attributes --queue-url $$TO_DISCORD_QUEUE --attribute-names ApproximateNumberOfMessages --profile $(AWS_PROFILE)

## =============================================================================
## CloudFront管理
## =============================================================================

.PHONY: cf-status
cf-status: ## CloudFrontディストリビューションのステータス確認
	@echo "📊 CloudFrontステータス:"
	aws cloudfront list-distributions \
		--profile $(AWS_PROFILE) \
		--query 'DistributionList.Items[*].[Id,Status,DomainName,Comment]' \
		--output table

.PHONY: cf-invalidate
cf-invalidate: ## CloudFrontキャッシュを削除
	@echo "🔄 CloudFrontキャッシュ削除中..."
	@DIST_ID=$$(cd terraform && terraform output -raw cloudfront_distribution_id 2>/dev/null); \
	aws cloudfront create-invalidation \
		--distribution-id $$DIST_ID \
		--paths "/*" \
		--profile $(AWS_PROFILE)

## =============================================================================
## Route53管理
## =============================================================================

.PHONY: route53-list
route53-list: ## Route53レコード一覧を表示
	@echo "📋 Route53レコード一覧:"
	@ZONE_ID=$$(cd terraform && terraform output -raw route53_zone_id 2>/dev/null); \
	aws route53 list-resource-record-sets \
		--hosted-zone-id $$ZONE_ID \
		--profile $(AWS_PROFILE) \
		--output table

## =============================================================================
## 監視・ステータス確認
## =============================================================================

.PHONY: billing-current
billing-current: ## 現在の課金量を確認（今月）
	@echo "💰 AWS課金情報を取得中..."
	@START_DATE=$$(date +"%Y-%m-01"); \
	END_DATE=$$(date -v+1d +"%Y-%m-%d" 2>/dev/null || date -d "tomorrow" +"%Y-%m-%d"); \
	echo "📊 課金情報 ($$START_DATE から $$END_DATE まで):"; \
	aws ce get-cost-and-usage \
		--time-period Start=$$START_DATE,End=$$END_DATE \
		--granularity DAILY \
		--metrics UnblendedCost \
		--profile $(AWS_PROFILE) \
		--output table

.PHONY: status-all
status-all: ## 全リソースのステータスを確認
	@echo "🔍 全リソースのステータス確認中..."
	@echo ""
	@$(MAKE) ec2-list
	@echo ""
	@$(MAKE) rds-status
	@echo ""
	@$(MAKE) cf-status

## =============================================================================
## SSM Parameter Store
## =============================================================================

.PHONY: ssm-list
ssm-list: ## SSM Parameter Store一覧を表示
	@echo "📋 SSM Parameter Store一覧:"
	aws ssm describe-parameters \
		--profile $(AWS_PROFILE) \
		--query 'Parameters[*].[Name,Type,LastModifiedDate]' \
		--output table

.PHONY: ssm-get
ssm-get: ## SSM Parameterの値を取得 (usage: make ssm-get PARAM=/path/to/param)
	@if [ -z "$(PARAM)" ]; then \
		echo "❌ PARAM変数を指定してください: make ssm-get PARAM=/path/to/param"; \
		exit 1; \
	fi
	@echo "🔍 SSM Parameter取得中: $(PARAM)"
	aws ssm get-parameter \
		--name "$(PARAM)" \
		--with-decryption \
		--profile $(AWS_PROFILE) \
		--query 'Parameter.Value' \
		--output text

## =============================================================================
## クリーンアップ
## =============================================================================

.PHONY: clean
clean: ## ローカルの一時ファイルを削除
	@echo "🧹 一時ファイル削除中..."
	rm -rf terraform/.terraform
	rm -f terraform/tfplan
	rm -f terraform/.terraform.lock.hcl
	@echo "✅ クリーンアップ完了"

